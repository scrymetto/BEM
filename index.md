# Введение

БЛОК – независимый компонент, может быть переиспользован (отражает смысл). Использовать class. Не CamelCase, разделять слова «-». **Он:**
* не влияет на свое окружение (НЕ задаёт отступы, границы, позиционирование)
* не использовать в CSS селекторы по тэгам или id.
* можно вкладывать друг в друга.

*Использовать:* когда повторяется и не зависит от реализации других компонентов.
ЭЛЕМЕНТ – не может использоваться отдельно от блока. Передаёт смысл. Использовать «__» после названия блока. **Он:**
1. допускает любую вложенность.
2. всегда – часть БЛОКА, а не другого элемента. 
3. необязателен.

*Использовать:* когда не может использоваться самостоятельно.

МОДИФИКАТОР – определяет вид, состояние или поведение (размер, тема, отключен, направление). Отделяется «_» от блока/элемента. Виды:
* булевый – когда важно только наличие/отсутствие, значение не существенно. Полный вид элемента с модификатором: `search-form__button search-form__button_disabled`.
* ключ-значение – когда важно значение. Полный вид элемента с модификатором: `search-form__button search-form__button_size_m`. Невозможно указывать два одинаковых модификатора с разными значениями!

**Он:** не может использоваться в отрыве от модифицируемого блока или элемента. Изменяет вид, а не заменяет сущность. `class="search-form_theme_islands"` – неверно! нужно `class="search-form search-form_theme_islands"`

МИКС – одновременно и блок, и элемент. Позволяет совмещать поведение и стили нескольких сущностей. Например, `class="search-form header__search-form"` в `class="header"`. Позволяет задать внешнее позиционирование в `header__search-form`, но при этом `search-form` оставить независимым.

## Файловая структура.

* один блок – одна директория.
* имя блока = имя директории.
* реализация блока разделяется на отдельные файлы-технологии (.js, .css)
* директория блока – корневая для поддиректорий его элементов и модификаторов.
* директории элементов начинаются с «__», модификаторы – с «_»
* Проект состоит из уровней переопределения

Схемы организации:
* nested (классическая, все пред. пункты)
* flat (без директорий для блоков, опциональные элементы/модификаторы – в отдельных файлах или в основном файле блока)
* flex (смешанная)

## БЭМ-дерево

Абстракция над DOM. Представление структуры в терминах БЭМ. BEMJSON – объект с обязательным полем «block» для блоков и «elem». Значение «block» - название класса, «elem» - то, что ставится после «__». Если блок содержит вложенные блоки/элементы, то они попадают в поле «content» в массив субблоков/элементов.

### Реализация блока. 

Реализация – это набор технологий, которые определяют особенности сущности:
* поведение
* внешний вид
* тесты
* шаблоны
* документацию
* описание зависимостей
* доп. данные.

Блоки могут быть реализованы в одной или нескольких технологиях:

* поведение – JS, CoffeeScript
* внешний вид – CSS, Stylus, Sass
* шаблоны – Pug, Handlebars, XSL, BEMHTML, BH
* документация – Markdown, Wiki, XML

«Блог реализован в технологии» = он есть в js, css и т.д.

ПЕРЕОПРЕДЕЛЕНИЕ блока – изменение реализации, путём добавления новых особенностей на другом уровне. 
Конечная реализация может быть разделена по разным уровням переопределения. Каждый последующий – добавляет или перекрывает предыдущий. Конечный результат собирается из всех пред. уровней последовательно в заданном порядке.

### Наименование.

Имя – УНИКАЛЬНО! Сущность именуется ОДИНАКОВО!
Правила:
* латиница в нижнем регистре
* для разделения слов – дефис
* имя блока задает ПРОСТРАНСТВО имен для его элементов и модификаторов
* имя элемента – через «__»
* имя модификатора – через «_»
* значение модификатора – через «_»
* значение булевых не указывается

Существуют также альтернативные стили - Two Dashes (булевые модификаторы и значения модификаторов отделяются от блоков/элементов «--», ), CamelCase, React (блоки и элементы – с заглавной буквы, использование CamelCase вместо «-», имя элемента отделяется от имени блока через «-»).

### CSS.

НЕ используются селекторы тегов и идентификаторов. 

НЕ рекомендуется совмещать теги и классы.

МИНИМУМ вложенных селекторов.

Правила одного блока НЕ ДОЛЖНЫ влиять на внутренний мир другого блока.

НЕ рекомендуется использование вложенных селекторов.

Внешняя геометрия и позиционирование задаются через родительский блок (для переиспользования дочерних элементов).

Чтобы не использовать групповые селекторы, делаются миксы – прибавляется булевое свойство, которое описывается в CSS (`class="article text"`). 

DRY! БЭМ-сущность имеет единственное, однозначное представление!

Переопределение! (создание двух кнопок, которые отличаются только цветом – описание css блока с общими параметрами -> создание модификаторов для каждого отдельного случая).

КОМПОЗИЦИЯ ВМЕСТО НАСЛЕДОВАНИЯ!

### HTML.

Для расположения блоков относительно другого или внутри него используются МИКСЫ (ввод доп. ЭЛЕМЕНТОВ со стилями (`<header class="header page__header">...</header>`)). Если невозможно – ОБЕРТКИ (ЭЛЕМЕНТЫ, содержащие стили с позиционированием).

Руками писать – неудобно (много ошибок). Принята *автоматическая генерация* HTML. Для этого используются ШАБЛОНЫ (реализация блока, результат работы которой - HTML). Код шаблонов – по принципам организации файловой структуры (см. выше). Можно писать отдельно для всего блока, можно для каждого элемента или модификатора.

Для переопределения блока, взятого из библиотеки – создается новая папка, в которую делаются новые шаблоны – нижнее правило переопределяет верхнее.

С помощью шаблонов можно добавлять и изменять блоки на ходу (`func content()`).

### JS.

Одна из технологий реализации блока, поэтому применяются основные принципы:
* единая предметная область
* разделение кода на части (использование инкапсуляции, декларативности и наследования)
* уровни переопределения и использование сборки
Полная независимость блоков невозможна, так как:
* они могу быть подписаны на события других блоков
* вызывать методы других объектов и стат. методов класса другого блока

Выстраивать блоки необходимо в ИЕРАРХИЧЕСКОМ порядке (в соответствии с DOM). ВЛОЖЕННЫЙ блок не должен ничего знать о РОДИТЕЛЬСКОМ.

Работа с модификаторами происходит с помощью *методов-хелперов*. Изменение значений модификаторов – с помощью методов, а не меняя напрямую класс-CSS.

Реакция на установку/снятие модификатора – применяется/отключается функциональность этого модификатора.

### Уровни переопределения.

Уровень переопределения – это ДИРЕКТОРИЯ с файлами реализации блоков/элементов/модификаторов (папка common для изменения, library для добавления). Нужны, чтобы добавить/изменить файлы проекта. В одном проекте могут быть разные варианты сборки в зависимости от разных условий (например, платформа). В таком случае базовая папка будет в любом случае входить в сборку, другие – опционально. Разделять можно:
* на платформы
* для обновления библиотек блоков
* для разработки проектов с общими блоками
* для создания разных тем
* для экспериментов в рабочей среде

УДОБНО, потому что обеспечивает сохранность изменений, быстрое переключение, легко удалять ненужные варианты.

### Изменение блоков.

С помощью **МОДИФИКАТОРА**: установка/снятие. Для:
* внешнего вида
* поведения (анимация – направление открытия блока)
* состояния (отключение видимости элемента)
* структуры (добавление элемента-«хвостика» для popup)

С помощью **МИКСА** – при помощи размещении доп. сущностей на одном элементе.
* позиционирование одного в составе другого: через РОДИТЕЛЬСКИЙ блок
* единая стилизация разных сущностей

С помощью **УРОВНЯ ПЕРЕОПРЕДЕЛЕНИЯ.** 
Изменение КОНТЕКСТОМ (размещение одного блока в составе другого, лучше НЕ использовать).

## Сборка.

Так как код разделён на разные файлы, их нужно объединять в один (один js, один css и т.п.). Файлы в результате сборки = бандлы.
Нужна для: 
* объединения исходных файлов
* подключения только необходимых блоков
* учёта порядка подключения
* обработки кода исходных файлов

Этапы сборки:
1) определение сущностей
2) определение зависимостей между сущностями
3) определение порядка их подключения.

Чтобы включить в сборку только необходимые сущности, нужно составить их список – ДЕКЛАРАЦИЮ. Инструмент сборки добавляет только их. Важно, чтобы попадала ИСХОДНАЯ реализация каждого блока (уровни переопределения ее дополняют или перекрывают). ИНСТРУМЕНТЫ – любые (Gulp, ENB).

### Декларация.

Список всех сущностей в формате BEMDECL (массив объектов exports.blocks, единственный ключ в котором – name, значение – название сущности в кавычках). Составляется вручную или автоматически – по описанию страницы (БЭМ-дерево) или с помощью интроспекции файловой структуры. Их можно *складывать, вычитать* или *делать пересечение.*

# i-bem.js

## Привязка JS-блоков.

Задача js-блока – установка реакции на событие внутри HTML. HTML – первичен, точка привязки блока – DOM-узел (HTML-элемент), в атрибуте class – имя блока, а в data-bem – параметры блока. При загрузке страницы выполняется ИНИЦИАЛИЗАЦИЯ блоков (+привязка JS-блоков, которые потом обрабатывают события на элементе и хранят его состояния).

**Для привязки блока к HTML-элементу, надо:**
* декларировать блок в i-bem: методы modules.define и bemDom.declBlock получают первым аргументом строку с именем этого блока:

```
modules.define('my-block', ['i-bem-dom'], function (provide, bemDom) {
    provide(bemDom.declBlock(this.name,
        { /* методы экземпляра */},
        {  /* статические методы */}
    ));
});
```
* Добавить  HTML-элементу class с именем блока.
* Добавить в этот класс «i-bem» - это укажет фреймворку, что элемент связан с блоком JS.
* Передать параметры элементу в атрибут «data-bem» в формате JSON: 
`<div class="my-block i-bem" data-bem='{ "my-block": { "name": "ya" } }'>...</div>`

Одному блоку – НЕ ОБЯЗАТЕЛЬНО 1 элемент. Варианты:
* 1 блок – 1 элемент 
* 1 блок на нескольких элементах (указание общего id в data-bem – для согласования нескольких компонентов блока – «вкладка» (первый элемент) по клику меняет «содержимое» (второй элемент))
* одному элементу соответствует несколько блоков (МИКСЫ – zB user+avatar)
* у блока нет элемента DOM (тогда необходимо явно инициализировать и удалять)

## Декларация блока.

В разных интерфейсах реализация блока/элемента может иметь несколько экземпляров. Экземпляры имеют помимо общей функциональности свою собственную. Терминами ООП – *блок/элемент = класс, экземпляр = экземпляр класса.* Вся функциональность решается через методы. МЕТОДЫ бывают:
* статические (методы класса)
* методы экземпляра

Код блока и элемента = ДЕКЛАРАЦИЯ.

#### Декларация с DOM-представлением: 

**Без родителя нового БЛОКА: *метод declBlock.*** АРГУМЕНТЫ: 
* имя (строка) или класс блока (функция)
* методы экземпляра (объект)
* методы класса (статические - объект)

Пример – см. прошлый.

**Без родителя нового ЭЛЕМЕНТА: *метод declElem.*** АРГУМЕНТЫ:
* имя (строка) или класс (функция) блока
* имя (строка) или класс (функция) элемента
* методы экземпляра (объект)
* методы класса (статические - объект)

Пример – такой же, как прошлый, только *declElem* вместо *declBlock.*

#### Декларация без DOM:

Так же.

Если НЕ планируется использовать именно бэм-блоки (модификаторы и тд), то можно оформлять в виде модуля:
```
modules.define('router', function(provide) {
    provide({
        route : function() { /* ... */ }
    });
});
```
Если есть общая функциональность (разные блоки делают одинаковые запросы и тд), то можно функции оформлять в виде модулей и добавлять их к блокам. НАСЛЕДОВАНИЕ помогает расширять новой логикой. **Оно бывает:**
* простым – указывается базовый блок, передается ссылка на него во втором параметре декларации:
```
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, {}));
    });
modules.define('b-block', ['i-bem-dom', 'a-block'], function(provide, bemDom, ABlock) {
    provide(bemDom.declBlock(this.name, ABlock, {}));
});
```
**Доопределяется** на уровне переопределения:
```
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, {})); // Объявляем базовый блок
});
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom, ABlock) {
    provide(bemDom.declBlock(ABlock, {})); // Доопределяем базовый блок
});
```
Для декларации МОДИФИКАТОРА – *declMod*. АРГУМЕНТЫ:
* хеш с ключами modName (имя модификатора: строка) и modVal (значение: строка, булевое, массив)
* хеш методов (при одноименных – используется из хэша)
```
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.decl(this.name, {})); // Объявляем базовый блок
});
modules.define('a-block', function(provide, ABlock) {
    provide(ABlock.declMod({ modName : 'm1', modVal : 'v1' }, {})); // Доопределяем базовый блок с модификтором _m1_v1
});
```
СТАТИЧЕСКИЕ методы НЕ будут изменены, так как относятся к классу.

Для декларации МИКСИНА  - *declMixin.* АРГУМЕНТЫ:
* методы экземпляра (объект)
* статические методы (объект)

Для ПРИМЕШИВАНИЯ МИКСИНА:
* указать примешиваемые миксиныв зависимостях
* передать ссылку на миксины во втором параметре блока (если декларируется наследование и миксин одновременно, то родительский класс – всегда ПЕРВЫЙ):
```
modules.define('b-block', ['i-bem-dom', 'a-block', 'a-mixin'], function(provide, bemDom, ABlock, aMixin) {
    provide(bemDom.declBlock(this.name, [ABlock, aMixin], {}));
});
```

УСТАНОВКА ТРИГГЕРА производится в декларации. Для них специальные свойства: *beforeSetMod* и *onSetMod.* АРГУМЕНТЫ:
* modName – имя модификатора
* modVal – выставляемое значение модификатора
* prevModVal – предыдущее значение модификатора – для *beforeSetMod*  - текущее, которое изменится на *modVal*, если триггер вернёт true
```
bemDom.declBlock(this.name, {
    onSetMod: {
        'mod1': function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
        'mod2': {
            'val1': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
            'val2': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
            '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
        },
        'mod3': {
            'true': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
            '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление простого модификатора mod3
        },
        'mod4': {
            '!val1' : function() { /* ... */ } // декларация для изменения mod4 в любое значение, кроме val1
            '~val2' : function() { /* ... */ } // декларация для изменения значения mod4 из val2 в любое другое значение
        },
        '*': function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
    }
})
```
В HTML указываются параметры в data-bem, объект, в котором ключ – имя блока, значение – объект. Если объектов много, то ключей несколько (каждый по имени блока). 

ПАРАМЕТРЫ ПО УМОЛЧАНИЮ передаются в методе *_getDefaultParams()*. Результат объединен с параметрами из атрибута (у которых больший приоритет):
```
modules.define('my-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, {
        _getDefaultParams : function() {
            return {
                param1 : 'val1'
                param2 : 'val2'
            }
        }	
    }));
});
```
ДОСТУП к параметрам из экземпляра – через *this.params.*

## Поиск других блоков. 

Каждый элемент/блок с DOM-представлением имеет поле this.domElem, которое является объектом, содержащим ссылки на все узлы, с которыми связан блок/элемент.

Поиск может вестись по трем осям:

#### Внутри блока – на узлах, ВЛОЖЕННЫХ в текущий. Методы:

* findChildBlock(block)
* findChildBlocks(block)
* findChildElem(elem)
* findChildElems(elem)

#### Снаружи блока, на узлах, которые являются РОДИТЕЛЬСКИМИ. Методы:

* findParentBlock(block)
* findParentBlocks(block)
* findParentElem(elem)
* findParentElems(elem)

#### На СЕБЕ (в случае миксов). Методы:

* findMixedBlock(block)
* findMixedBlocks(block)
* findMixedElem(elem)
* findMixedElems(elem)

Для оптимизации – КЭШИРУЮЩИЕ методы *\*._elem(elem), \*._elems(elem)* – принимают элемент (строка, функция, объект вида `{elem : MyElem, modName : 'my-mod', modVal : 'my-val' }`) – одновременно ищет по ДВУМ ОСЯМ (внутри и на себе). НЕ сохраняется в переменную. Для БЛОКОВ - *\*._block().* ВЛОЖЕНННОСТЬ проверяется функцией *containsEntity(entity).*

## Динамическое обновление блоков.

* УДАЛЕНИЕ - *destruct(ctx, [excludeSelf]).* Параметры: *ctx* – корневой DOM-элемент. Не даляется со всеми вложенными узлами, если *\[excludeSelf\]* true. По умолчанию - false. 
* ДОБАВЛЕНИЕ:
1) *append(ctx, content)* – в конец
2) *prepend(ctx, content)* – в начало
3) *before(ctx, content)* – перед указанным
4) *after(ctx, content)* – после указанного
* ЗАМЕЩЕНИЕ:
1) *update(ctx, content)* – внутри указанного
2) *replace(ctx, content)* – заменить указанным

ДЛЯ УПРОЩЕНИЯ можно использовать ШАБЛОНИЗАТОР BEMHTML (сущности описываются в формате BEMJSON, `BEMHTML.apply` генерирует элементы по декларации)

## Состояния блоков и элементов.

Вся логика: описание состояний, которые запускаются, как только срабатывает триггер. Поэтому **описание состояния – действия, выполняемые при переходе в это состояние.**

СОСТОЯНИЕ описывается *модификаторами.* Он описывает, в каком состоянии находится блок. Список допустимых значений = набор состояний. zB для описания размеров – модификатор size со значениями s, m, l. Модификатор с неуказанным значением = булев, по умолчанию true. УСТАНАВЛИВАЮТСЯ при **инициализации** (если модификаторы используются в атрибуте class HTML-элемента). При УСТАНОВКЕ (если модификатор НЕ был указан в class HTML-элемента), ИЗМЕНЕНИИ, УДАЛЕНИИ – выполняется триггер. 

МЕТОДЫ для управления модификаторами:
* hasMod(modName, \[modVal\])
* getMod(modName) – возвращает значение модификатора
* setMod(modName, \[modVal=true\]) – устанавливает модификатор
* toggleMod(modName, modVal1, \[modVal2\], \[condition\]) – переключает модификатор. Если передан аргумент modVal2, то переключится с modVal1 на modVal2, если нет, то будет поочередно устанавливаться и удаляться. Если condition = true, то порядок переключения инвертирован
* delMod(modName)

ВЫПОЛНЕНИЕ триггеров делится на 2 фазы:
1) до установки модификатора – если хотя бы один триггер возвращает false, то модификатор не ставится
2) после установки. Отменить нельзя.

Типы изменения модификаторов для триггеров:
* любой модификатор в любое значение
* конкретный модификатор в любое значение
* конкретный модификатор в конкретное значение
* установка модификатора в значение ‘’ (пустая строка) = удаление его или false для булева
* установка конкретного модификатора в любое, кроме конкретного значения
* установка конкретного модификатора из конкретного значения в любое другое

При ОПРЕДЕЛЕНИИ триггера указывается:
1) фаза выполнения (до или после установки модификатора)
2) тип действия (имя или значение модификатора)

ФАЗА ВЫПОЛНЕНИЯ до установки модификатора, чтобы проверить, установлены ли какие-то другие модификаторы (например, нет смысла ставить focused, если стоит disabled:
```
bemDom.declBlock('searchbox', {
    beforeSetMod : {
        'focused' : {
            'true' : function() {
                return !this.hasMod('disabled');
            }
        }
    },
    onSetMod : {
        'focused' : {
            'true' : function() { /* ... */ }
        }
    }
});
```
)

## Коллекции блоков и элементов.

СОЗДАНИЕ экземпляра класса КОЛЛЕКЦИИ – с помощью класса *BemCollection,* если модуль i-bem__collection, или *BemDomCollection,* если модуль i-bem-dom__collection. В качестве АРГУМЕНТОВ принимает один аргумент-массив или несколько аргументов:
```
modules.define(
'my-form',
['i-bem-dom', 'i-bem-dom__collection', 'button', 'input'],
function(provide, bemDom, BemDomCollection, Button, Input) {
    provide(bemDom.declBlock(this.name, {
        onSetMod : {
            'js' : {
                'inited' : function() {
                    var button = this.findChildBlock(Button);
                    var input = this.findChildBlock(Input);
                    this._controls = new BemDomCollection(button, input);
                }
            }
        }
    }));
});
```
МЕТОДЫ коллекции:
* *setMod*(modName, \[modVal=true\]), *delMod*(modName), *toggleMod*(modName, modVal1, \[modVal2\], \[condition\]) – так же
* *everyHasMod*(modName, \[modVal\]), *someHasMod*(modName, \[modVal\]) = *hasMod*(modName, modVal) для каждой сущности коллекции
* *get*(i) – возвращает элемент коллекции по индексу i
* *size*() – размер коллекции
* *forEach*(fn, ctx), *map*(fn, ctx), *reduce*(fn, ctx), *reduceRight*(fn, ctx), *filter*(fn, ctx), *some*(fn, ctx), *every*(fn, ctx), *has*(entity), *find*(fn, ctx), *concat*(...args) – методы массива
* *toArray*() – преобразовывает коллекцию в массив

## События.

События бывают 2х видов: DOM и БЭМ. Первые – только для взаимодействия со своим узлом и своими блоками, для взаимодействия с другими блоками – БЭМ-события.

### DOM-СОБЫТИЯ

ИЗ ЭКЗЕМПЛЯРА

Для ПОДПИСКИ на событие - *_domEvents()*, который создаёт специальный объект менеджера событий. Принимает 1 параметр (опционально), который ЗАДАЁТ КОНТЕКСТ. Виды:
* *elemInstance* {Elem|BemDomCollection} – экземпляр или коллекция элементов
* *elemClass* {String|Function|Object} – класс, имя или описание объекта (в виде хэша `{elem : MyElem, modName : 'my-mod', modVal : 'my-val'}`) 
* *document* {Document|jQuery}
* *window* {Window|jQuery}

zB:
```
bemDom.declBlock('my-form', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this._domEvents('button').on('click', this._onSubmit);
            }
        }
    },
    _onSubmit : function() { /* ... */ }
});
```
ИЗ КЛАССА – статический метод *_domEvents().* Принимает:
* *elemClass* {String|Function|Object} – класс, имя или описание вида `{elem : MyElem, modName : 'my-mod', modVal : 'my-val' }`
* *document* {Document|jQuery}
* *window* {Window|jQuery}

zB:
```
bemDom.declBlock('my-form', {
    _onSubmit : function() { /* ... */ }
}, {
    lazyInit : true,
    onInit : function() {
        this._domEvents('button').on('click', this.prototype._onSubmit);
    }
}); //при нажатии на любую кнопку класса, будет выполняться _onSubmit
``` 
УДАЛЕНИЕ подписки – автоматически при удалении экземпляра, или через *_domEvents().un*

Первым аргументом функция-обработчик получает объект события, поэтому можно использовать *stopPropagation* и *preventDefault,* чтобы остановить всплытие и реакцию браузера.

## БЭМ-СОБЫТИЯ

Генерируются НЕ на DOM, а на экземплярах блоков.
Для генерации – метод *_emit(event, \[data\]).* event – имя или объект события, \[data\] – доп данные для события.

Взаимодействие пользователя с блоком -> DOM-событие -> обработка событий блоком -> создание БЭМ-события.

#### ИЗ ЭКЗЕМПЛЯРА

ПОДПИСКА – метод *_events(),* который создает объект менеджера событий. Принимает параметр, задающий КОНТЕКСТ. Виды:
* *entityInstance* {Elem|BemDomCollection} – экземпляр или коллекция сущностей
* *entityClass* {String|Function|Object} – класс, имя или описание (хэш все того же вида)

zB:
```
modules.define('my-form', ['i-bem-dom', 'button'], function(provide, bemDom, Button) {
    provide(bemDom.declBlock(this.name, 
        {
        _onSubmit: function() { /* ... */ }
        }, 
        {
            lazyInit : true,
            onInit : function() {
                this._events(Button).on('click', this.prototype._onSubmit)
            }
        }
    ));
});
```
Существуют так же специальные события на ИЗМЕНЕНИЕ МОДИФИКАТОРОВ. Используется хэш с полями modName – имя, modVal – значение. Значение «*» - применяется к изменению на все изменения, «””» - на удаление модификатора.

#### ОБЪЕКТ МЕНЕДЖЕРА СОБЫТИЙ

* метод on(event, \[data\], fn) – для подписки на событие event обработчика fn с возможностью передать ему данные \[data\].
* метод once(event, \[data\], fn) – единоразовая подписка
* метод un(\[event\], \[fn\]) – для отписки. Если не указан обработчик fn, то удаляются все обработчики события.

zB:
```
modules.define('my-form', ['i-bem-dom', 'button'], function(provide, bemDom, Button) {
    bemDom.declBlock('form', {
        onSetMod: {
            'js': {
                'inited': function() {
                    this._events(this.findChildBlock(Button))
                        .on({ modName : 'disabled', modVal : '*' }, this._onButtonDisabledChange);
                }
            }
        },
        _onButtonDisabledChange() {}
    });
});
```

## Инициализация

Создание в памяти браузера js-объекта, который соответствует экземпляру блока или элемента. Выполняется функцией *init(\[ctx\])* на заданном фрагменте DOM-дерева ctx. Существует в 3 состояниях:
1) не создан объект = не инициализирован
2) создан объект = инициализирован
3) уничтожены все ссылки, может быть удалён gc

Описываются с помощью модификатора js – `<div class="my-block i-bem my-block_js_inited" data-bem='{ "my-block" : {} }'>...</div>` - модификатор в значении inited.

Если фрагмент DOM-дерева удалён (метод *destruct()*), то с ним удаляются все элементы. Перед удалением убирается модификатор JS.

На установку модификатора js можно назначить ТРИГГЕР (его можно считать конструктором):
```
bemDom.declBlock('my-block', {
    onSetMod : {
        'js' : {
            'inited' : function() { /* ... */ } // конструктор экземпляра
        }
    }
});
```
Деструктор – триггер на УДАЛЕНИЕ (вместо 'inited' - '').

Инициализируются не сразу все блоки (динамически, по событию или запросу) – это ВОЛНЫ инициализации. Создаются, если:
* автоматически по событию *domReady*
* ленивая инициализация
* явный вызов инициализации на указанном фрагменте

АВТОМАТИЧЕСКИ можно включить, указав это в файле зависимостей *.deps.js*:
```
({
    shouldDeps : [
        {
            block : 'i-bem',
            elem : 'dom',
            mods : { init : 'auto' }
        }
    ]
})
```
ЛЕНИВАЯ – если много элементов, то нежелательно использовать автоматическую инициализацию, только в тот момент, когда она требуется пользователю (например, по клику). Для декларации такой загрузки – статическое свойство *lazyInit* (булево значение):
```
modules.define('my-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, 
        {
            onSetMod : {
                'js' : {
                    'inited' : function() {
                        // этот код будет выполняться при первом обращении к экземпляру блока
                    }
                }
            }
        }, 
        {
            lazyInit : true
        }
    ));
});
```
Можно отменить для конкретного экземпляра, установив в HTML `data-bem='{ "my-block" : { "lazyInit" : false } }'`.

Для класса  - специальный дополнительный метод onInit, внутри которого можно подписаться на события:
```
modules.define('button', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, 
        {
            onSetMod : {
                'js' : 
                    {
                    'inited' : function() { // выполняется при первом DOM-событии "click" }
                    }
                },
                _onClick: function(e) { // выполняется при каждом DOM-событии "click" }
            }, 
            {
                lazyInit : true,
                onInit : function() {
                    this._domEvents().on( 'click', this.prototype._onClick);  // в момент клика будет создан экземпляр блока и вызван его метод _onClick
            }
        }
    ));
});
```
**NB!** Методы – СТАТИЧЕСКИЕ, поэтому будут применены КО ВСЕМ ЭКЗЕМПЛЯРАМ класса!

Инициализация может быть вызвана ЯВНО (при динамическом обновлении). Для этого методы:
* *init(), destruct()* – инициализация и уничтожение экземпляров
* *update(), replace(), append(), prepend(), before(), after()* – обновление фрагмента дерева с одновременной инициализацией.

#### БЕЗ DOM

Для ИНИЦИАЛИЗАЦИИ – статический метод *create().* АРГУМЕНТЫ:
* *mods* (объект) – модификаторы
* *params* (объект) – параметры блока/элемента

Автоматически НЕ удаляются (так как это обычные объекты, их подчищает gc после уничтожения всех ссылок на него).

## Взаимодействие блоков и элементов. 

Следует разрабатывать так, чтобы состояния сущностей НЕ ЗАВИСИЛИ от других сущностей. Но на практике – так себе получается.

Взаимодействие реализовано:
* подписками на БЭМ-события
* непосредственный вызов других экземпляров и статических методов класса
* проверка состояния одного экземпляра из другого
* НЕ ИСПОЛЬЗОВАТЬ ДЛЯ ЭТОГО DOM!

Для реализации взаимодействия:
* поиск экземпляров в DOM
* доступ к экземплярам без DOM
* доступ к классам и объектам

## Контекст

В методах ЭКЗЕМПЛЯРА **this** указывает на экземпляр, в СТАТИЧЕСКИХ – на класс. Внутренние методы, которые не используются извне, принято начинать с «_».

**Свойства и методы:**
* *params* (параметры, переданные в HTML или экземпляру при инициализации (если нет DOM-представления))
* *domElem* (только у сущностей с DOM-представлением) – объект jQuery с ссылками на DOM-элементы
* *__self* – для доступа к статическим методам из экземпляра:
```
bemDom.declBlock('my-block', 
    {
        _onEvent : function() {
            this.__self.staticMethod(); // вызов статического метода
            this.doMore();
        }
    }, 
    {
        staticMethod : function() { /* ... */ } // определение статического метода
    }
);
```
* *__base*  - для вызова реализации одноименного метода из класса-родителя («super call»)
* *_nextTick(fn)* – асинхронно вызывает fn в следующем витке событий. Вызывается в контексте данного экземпляра, если он ещё существует

# BEMJSON

## Стандартные поля:

* *block* – имя блока (строка)
* *elem* – имя элемента  (строка)
* *mods* – хеш модификаторов БЛОКА – объект. Ключи – любые, значения – строка или булево. Будет ПРОИГНОРИРОВАН, если указаны elem и elemMods
* *elemMods* – хеш модификаторов ЭЛЕМЕНТА –II– ИГНОРИРУЕТСЯ, если не указан elem
* *content* – дочерние узлы. Объект с полем html – специальная сущность, значение – строка, которая будет выведена без изменений. Остальное ИГНОРИРУЕТСЯ
* *mix* – примиксованные сущности (объект, строка)
* *bem* – нужно ли дополнять классы и параметры для самой БЭМ-сущности (булево – если false, то в результате HTML не изменится)
* *js* – параметры (объект/булево – если не false, то миксует i-bem и добавляет содержимое в data-bem:

```
//BEMJSON
{
   block: 'link',
   js: true
})
//HTML
<div class="link i-bem" data-bem='{"link":{}}'></div>
```

При этом кавычки и спец. символы будут экранированы)
* *attrs* - хеш HTML-атрибутов (объект. спец. символы экранируются: )

```
//BEMJSON
{
    attrs: {
        id: 'anchor',
        name: 'Мультфильм "Tom & Jerry"'
    }
}
//HTML
<div id="anchor" name="Мультфильм &quot;Tom &amp; Jerry&quot;"></div>
```

* *cls* - HTML-класс (строка – класс или классы, которые не принадлежат БЭМ)
* *tag* - HTML-тэг (булево/строка. Если false или '' – указание пропустить генерацию этого тэга. По умолчанию - div)
* *пользовательские поля*

# bem-xjst

Шаблонизатор на двух движках: 
* BEMHTML для преобразования BEMJSON в HTML
* BEMTREE для навешивания на BEMJSON БЭМ-дерева и преобразования этого в HTML

## Написание шаблона.

Шаблон состоит из:
* **предиката** (у каждого шаблона прописываются входные условия, подпредикаты, они составляют предикат). Бывают:
1) *block* (запрашивает подпредикат имени блока)
2) *elem* (то же самое, но элемента)
3) *mod* (запрашивает modName, modVal)
4) *elemMod* (elemModName, elemModVal)
5) *match* (`(node, ctx) => { return … }` проверка произвольного условия. Результат приведён к булеву значению)

Чейнятся. Можно вкладывать друг в друга во избежание дублирования кода.
* **тела** (инструкция по генерации результата работы шаблона). Шаблонизация каждого узла входных данных состоит из режимов (тэг, HTML-класс, атрибуты, содержание тэга). РЕЖИМ = вызов функции. Нельзя в сам режим передавать аргументы. Тело шаблона – отдельный вызов функции, который ожидает аргумент (`block('b').content()('test')`); 
или: для сокращённого вида).

```
block('link')({
   tag: 'a',
   attrs: (node, ctx) => ({ href: ctx.url })
}); 
```

## СТАНДАРТНЫЕ режимы:

* *def* (def: value) – отвечает в целом за генерацию результата. Не стоит пользовать.
* *tag* (tag: name, по умолчанию div) – тэг. Если отсутствует – то пропускается
* *attrs* (attrs: value) – хэш с атрибутами. Более коротко - `addAttrs: { id: 'test', name: 'test' }`
* *content* – дочерние узлы. Чтобы добавить в содержимое - *appendContent* и *prependContent.*
zB:

```
block('quote')(
    {
        prependContent: '«',
        appendContent: '»'
    },
    {
        appendContent: () => ({ block: 'link' })
    }
);
{ block: 'quote', content: 'Пришел, увидел, отшаблонизировал' }
```

Результат:

```
<div class="quote">«Пришел, увидел, отшаблонизировал»<div class="link"></div></div>
```

По сути – синтаксический сахар над *applyNext().*
* *mix* – сущности, которые примиксовываются (либо `{ mix: { block: 'mixed' } }`, либо массив объектов, либо функция, либо `addMix: 'my-new-mix'`)
* *mods* – модификаторы блока. Для добавления – *addMods* (ключом – хэш модификаторов)
* *elemMods* – модификаторы элемента (всё то же самое)
* *js* – если не false, то миксует i-bem и добавляет содержимое в js параметры
* *bem* – указывает, добавлять ли классы и параметры для БЭМ и миксов
* *cls* – добавить любой класс, который не относится к БЭМ

## ХЕЛПЕРЫ

* *replace* – для подмены текущего узла
* *wrap* – для обертки узла:

```
{
    block: 'quote',
    content: 'Docendo discimus'
};
block('quote')({
    wrap: (node, ctx) => ({
        block: 'wrap',
        content: ctx
    })
});
```

Результат:

```
<div class="wrap">
    <div class="quote">Docendo discimus</div>
</div>
```

* *extend* – доопределить контекст:

```
{ block: 'action' };
block('action')({
    extend: { 'ctx.type': 'Sale', sale: '50%' }
});
block('action')({
    content: (node, ctx) => ctx.type + ' ' + node.sale
});
```

Результат:

```
<div class="action">Sale 50%</div>
```

Если указать «*», то распространяется на все дочерние блоки/элементы.
* *пользовательские режимы:* сам решаешь, что и как:

```
{ block: 'control', name: 'username', value: 'miripiruni' }

block('control')(
    {
        id: 'username-control', // Пользовательский режим с именем id
        content: (node, ctx) => {
            return [
                {
                    elem: 'label',
                    attrs: { for: apply('id') } // Вызов пользовательского режима
                },
                {
                    elem: 'input',
                    attrs: {
                        name: ctx.name,
                        value: ctx.value,
                        id: apply('id')  // Вызов пользовательского режима
                    }
                }
            ];
        }
    },
    elem('input')({ tag: 'input' }),
    elem('label')({ tag: 'label' })
);
```
Результат:
```
<div class="control">
    <label class="control__label" for="username-control"></label>
    <input class="control__input" name="username"
        value="miripiruni" id="username-control" />
</div>
```

## Тело шаблона

В процессе обхода входных данных bem-xjst строит КОНТЕКСТ, который **содержит**:
* сведения о БЭМ-сущности
* текущий узел 
* хелперы
* кастомные поля
* методы для управления шаблонизацией

Если тело шаблона является ФУНКЦЕЙ, то она вызывается с двумя аргументами:
* контекст (this в теле шаблона)
* текущий узел, к которому привязан шаблон (this.ctx)

```
block('link') ({
    attrs: function(node, ctx) {
        return {
            // тоже самое что и this.ctx.url
            href: ctx.url,

            // тоже самое что и this.position
            'data-position': node.position
        };
    }
});
```

Поддержка СТРЕЛОЧНЫХ функций (можно использовать вместо return)

#### Нормализация сведений о сущности

В узле может не быть каких-то сведений (например, у дочернего элемента (находящегося под ключом content) не указан блок). Шаблонизатор исправляет это. Он следит за следующими полями:
1. this.block
2. this.elem
3. this.mods
4. this.elemMods

Поэтому не нужно выполнять на них проверку.

#### Текущий узел

Доступен в поле this.ctx:

```
{
    block: 'company',
    name: 'yandex'
}

block('company')({
    attrs: (node, ctx) => ({
        id: ctx.name,
        name: ctx.name
    })
});

```

Результат:

```
<div class="company" id="yandex" name="yandex"></div>
```

#### Хелперы

**Методы экранирования:**
* *xmlEscape* - принимает строку, возвращает её же, но с хаэкранированными символами `&`, `<`, `>`. Если пришло невалидное значение, то вернёт пустую строку. Если не строка - то приведет к строке. Используется в с ключом `def`:
```
block('button')({
    def: (node) => node.xmlEscape('<b>&</b>')
});
```
* *attrEscape* - то же самое, но символы `"` и `&`. 
* *jsAttrEscape* - символы `'` и `&`.

**Определение позиции:**
* *this.position* - ЧИСЛО, соответствующее порядковому номеру сущности среди её соседей в дереве (одноранговых). При вычислении:
    * нумеруются только те, у кого есть БЭМ-сущность
    * начиная с 1
    * другие сущности остаются без номера
zB:
```
{
    block: 'page',                // this.position === 1
    content: [
        { block: 'head' },        // this.position === 1
        'text',                   // this.position === undefined
        {
            block: 'menu',        // this.position === 2
            content: [
                { elem: 'item' }, // this.position === 1
                'text',           // this.position === undefined
                { elem: 'item' }, // this.position === 2
                { elem: 'item' }  // this.position === 3
            ]
        }
    ]
}
```

Дерево может быть ДОСТРОЕНО в процессе ВЫПОЛНЕНИЯ в режиме `def` или `content`. Позиция учитывается. `this.isLast()` НЕ сработает, если после эелемента есть что-то, даже если это НЕ БЭМ-сущность.
* *isFirst* - проверка, первый ли узел
* *isLast* - проверка, последний ли узел

**Генератор уникальных id**
* *this.generateId()*:
```
block('input')({
    content: (node, ctx) => {
        var id = node.generateId();

        return [
            {
                tag: 'label',
                attrs: { for: id },
                content: ctx.label
            },
            {
                tag: 'input',
                attrs: {
                    id: id,
                    value: ctx.value
                }
            }
        ];
    }
});
```

Результат:

```
<div class="input">
    <label for="uniq14563433829878">Имя</label>
    <input id="uniq14563433829878" value="Иван" />
</div>
```

**Ещё:**
* *this.isSimple({*} arg)* - является ли `arg` примитивом
* *this.isShortTag({String} tagName)* - нужен ли для `tagName` закрывающий тэг
* *this.extend({Object} o1, {Object} o2)* - создаёт новый объект, куда складывает все поля из `o1`, потом из `o2`
* *this.reapply()* - позволяет шаблонизировать произвольные данные, находять в самом шаблоне, а на выходе получить строку:
```
{ block: 'a' }
block('a')({
    js: (node) => ({
        template: node.reapply({ block: 'b', mods: { m: 'v' } })
    })
});
```
Результат:

```
<div class="a i-bem" data-bem='{
    "a":{"template":"<div class=\"b b_m_v\"></div>"}}'></div>
```

#### Кастомные поля:

Контекст можно расширить при помощи прототипа:

```
var bemxjst = require('bem-xjst');
var templates = bemxjst.bemhtml.compile('');

// Расширяем прототип контекста
templates.BEMContext.prototype.hi = function(name) {
    return 'Hello, ' + username;
};

// Добавляем шаблоны
templates.compile(() => {
    block('b')({
        content: (node) => node.hi('templates')
    });
});

var bemjson = { block: 'b' };

// Применяем шаблоны
var html = templates.apply(bemjson);
```

Результат:

```
<div class="b">Hello, templates</div>
```

#### Таннелинг дочерним узлам

Можно так же передать ДОЧЕРНИМ сущностям какие-либо флаги через ключ `extend`:

```
[
  {
      block: 'qa-form',
      content: [
          { block: 'input' },
          …
      ]
  },
  { block: 'input' }
]

// выставляем флаг _inQaForm, который будет доступен
// из всех узлов внутри данного
block('qa-form')({ extend: { _inQaForm: true } });

block('input')
  // подпредикат, который проверяет, что флаг взведен
  .match((node) => node._inQaForm)
  .mix()({ mods: { inside: 'qa' } });
```

Результат:

```
<div class="qa-form">
    <div class="input input_inside_qa"></div>
</div>
<div class="input"></div>
```

## Runtime

СУТЬ: шаблонизатор рекурсивно объодит дерево элементов в прямом порядке и ищет шаблон для каждого элемента. В теле шаблона он может быть заменен на другой или дополнен. Если шаблонов нет, то сгенерирует результат по умолчанию.

Шаблоны располагаются в упорядоченном списке. Приоритет отдаётся последним. Для каждого узла проверяются предикаты каждого шаблона, для этого выполняются подпредикаты. Если все они вернули true - поиск прекращается и выполняется текущий шаблон. Если шаблон не найден, то выполняется поведение по умолчанию.

**Чтобы установить шаблон на все сущности, следует указать** `'*'`:

```
[
    { block: 'header' },
    { block: 'link', mix: [{ block : 'title' }], counter: '1549865' },
    { block: 'snippet', counter: '1549865' }
]
```

```
block('*')
    .match((node, ctx) => ctx.counter)({
        mix: (node, ctx) => ({
            block: 'counter', js: { id: ctx.counter }
        })
    })
```

Результат:

```
<div class="header"></div>
<div class="link counter title i-bem" data-bem='{"counter":{"id":"1549865"}}'></div>
<div class="snippet counter i-bem" data-bem='{"counter":{"id":"1549865"}}'></div>
```

## Инструкции выполнения

* *apply* - `apply(modeName, changes)` - *modeName* - название режима, над которым будут производиться действия, *changes* - объект, которым расширяется контекст выполнения. **Применяется** для вызова стандартного или пользовательского режима текущего узла.

```
{ block: 'button' }

block('button')({
    test: (node, ctx) => node.tmp + ctx.foo,
    def: () => apply('test', {
        tmp: 'ping',
        'ctx.foo': 'pong'
    })
});
```

Если используется пользовательский режим (например, size), то через вызов `apply('size')` его можно переопределить, например:

```
block('my-block')({
    size: 'm',
    content: () => ({
        block: 'button',
        size: apply('size')
    })
});

block('my-block').mode('size')('l');

block('my-block').mode('size')('s');
```

* *applyNext* - `applyNext(changes)` - *changes* - объект, которым расширяется контекст выполнения. **Применяется:** для возвращения результата работы следующего по приоритету узла в текущем режиме для текущего узла:

```
block('link')({ tag: 'a' });
block('link')({
    tag: () => {
        var res = applyNext(); // res === 'a'
        return res;
    }
});
```

* *applyCtx* - `applyCtx(bemjson, changes)` - *bemjson* - входные данные, *changes* как всегда. **Применяется:** для модификации текущего фрагмента `this.ctx` с применением шаблона `apply()`:

```
{ block: 'header', mix: [{ block: 'sticky' }] }

block('header')({
    def: (node, ctx) => applyCtx(node.extend(ctx, {
        block: 'layout',
        mix: [{ block: 'header' }].concat(ctx.mix || [])
    }));
});
```

Результат:

```
<div class="layout header sticky"></div>
```

## Описание зависимостей

Для ЯВНОГО указания зависимостей используются файлы-технологии *deps.js*. Описываются зависимости сущностей, которые НЕ ОТРАЖЕНЫ в декларации. Например, есть шаблон с формой, в которой внутри содежатся блоки с инпутом и кнопкой, взятые из другой библиотеки. в папке с формой создаём файл **имя-файла*.deps.js*, куда прописываем:

```
({
    shouldDeps: [
        { block: 'input' },
        { block: 'button' }
    ]
})
```

В итоге все файлы из библиотеки, опысывающие блоки input и button (css и js, лежащие в папке lib), попадут в сборку. 
Для короткой записи зависимостей в комментариях пишут следующее:
* `/* b1 → b2 */` - блок b1 зависит от b2 (shouldDeps)
* `/* b1 ⇒  b2 */` - блок b1 зависит от b2 (mustDeps)
* `/* b1 → b1__e1 */` - блок b1 зависит от своего элемента b1__e1
* `/* b1 → b1_m1_v1 */` - блок b1 зависит от своего модификатора b1_m1_v1
* `/* b1 → b1__e1_m1_v1 */` - блок b1 зависит от модификатора своего элемента b1_m1_v1
* `/* b1.js → b2.bemhtml */` - блок b1 в технологии js зависит от блока b2 в технологии bemhtml

#### Синтаксис

Полная реализация:

```
/* DEPS-сущность */
({
    block: 'block-name',
    elem: 'elem-name',
    mod: 'modName',
    val: 'modValue',
    tech: 'techName',
    shouldDeps: [ /* БЭМ-сущность */ ],
    mustDeps: [ /* БЭМ-сущность */ ],
    noDeps: [ /* БЭМ-сущность */ ]
})
```

Поля *block*, *elem*, *mod*, *val* определяют БЭМ сущность, которая будет зависеть от чего-то. Поле *tech* отвечает за технологию реализации, для которой собираются зависимости. Если не указать - считается общей для всей реализации. Поля *shouldDeps *, *mustDeps *, *noDeps * определяют зависимости. Они выражаются в массиве или объекте и означают следующее:
* *shouldDeps* - порядок подключения зависимостей не важен
* *mustDeps* - зависимости, которые попадут в сборку ДО объявления самой сущности в коде 
* *noDeps* - отменяет зависимости, объявленные на других уровнях переопределения (например, i-bem__dom_init_auto)

# BEM + REACT

## Библиотека *className*

Функция **`cn(arg)`**, которая генерирует имя класса в соответствии с технологией БЭМ. При передаче 1 аргумента - БЛОКА, с 2 - ЭЛЕМЕНТА. Возвращает всегда ФУНКЦИЮ! Вызов возвращённой функции возвращает всегда СТРОКУ! Если вызывалась с 1 аргументом, то при вызове возвращённой функции вернет имя ЭЛЕМЕНТА.При вызове возвращенной функции с объектом в качестве аргумента возвращает имя МОДИФИКАТОРА.

```
import { cn } from '@bem-react/classname';

const cat = cn('Cat');

cat(); // Cat
cat({ size: 'm' }); // Cat Cat_size_m
cat('Tail'); // Cat-Tail
cat('Tail', { length: 'small' }); // Cat-Tail Cat-Tail_length_small

const dogPaw = cn('Dog', 'Paw');

dogPaw(); // Dog-Paw
dogPaw({ color: 'black', exists: true }); // Dog-Paw Dog-Paw_color_black Dog-Paw_exists
```

Для примиксовывания - функция **`classnames(arg)`**:

```
import { classnames } from '@bem-react/classname';
classnames('Block', 'Mix', undefined, 'Block'); // 'Block Mix'
```

Для изменения самого наименования - функция **`withNaming(obj)`**:

```
import { withNaming } from '@bem-react/classname';

const cn = withNaming({ n: 'ns-', e: '__', m: '_' });

cn('block', 'elem')({ theme: 'default' }); // ns-block__elem_theme_default
```

## Библиотека *core*

Функция **`withBemMod(blockName, condition, JSX-component)`**

Аргументы:
* *blockName* - строка - имя изменяемого блока
* *condition* - объект - условие, при котором будет применяться модификатор. Вид - `{type: 'text'}` - если true, то функция сработает. True - если в JSX в параметрах есть `type='text'`
* *JSX-component* - разметка JSX, которая применится к блоку, если предыдущее условие true

Функции **`compose(bemModFuncs)(Base)`**, **`composeU(bemModFuncs)(Base)`**. В случае, если используются модификаторы с одинковым значением, то используется `composeU(arg)` (может быть вложена в качестве аргумента в `compose(arg)`, тогда *Base* не указывается). Главное - ОБРАТИТЬ ВНИМАНИЕ НА ПРАВИЛЬНЫЙ ПОРЯДОК! То, что указано ПЕРВЫМ, будет первым отрендерино!

Аргументы:
* *bemModFuncs* - функция/функции, возвращаемые из `withBemMod()`
* *Base* - компонент/класс/функция - исходный блок


Все функции при этом разбрасываются по разным файлам/папкам.

Пример:

```
//Components/Button/ButtonDef.js

export const ButtonDef: = ({ text, className }) => ( 
  <div className={className}>{text}</div>
);
```

```
//Components/Button/_type/Button_type_link.js

const ButtonLink = (Base, { text, className }) => (
  // className === 'Button Button_type_link'
  <a className={className}>{text}</a>
);

export const ButtonTypeLink = withBemMod('Button', { type: 'link' }, ButtonLink);
```

```
//Components/Button/_theme/Button_theme_action.js

export const ButtonThemeAction = withBemMod('Button', { theme:  'action' });
```

```
//Components/Button/Button.js ???

export const Button = compose(
  composeU(withButtonThemeAction, withButtonThemeDefault), //withButtonThemeDefault для примера использования
    withButtonTypeLink,
  )(ButtonDef);
```

```
//App.js

export const App = () => {
  <div className="App">
    <Button text="I'm basic" />   
    // Renders into HTML as: <div class="Button">I'm Basic</div>                                    

    <Button text="I'm type link" type="link" />    
    // Renders into HTML as: <a class="Button Button_type_link">I'm type link</a>

    <Button text="I'm theme action" theme="action" />
    // Renders into HTML as: <div class="Button Button_theme_action">I'm theme action</div>

    <Button text="I'm all together" theme="action" type="link" />
    // Renders into HTML as: <a class="Button Button_theme_action Button_type_link">I'm all together</a>
  </div>
}
```

## Библиотека *Dependency Injection (DI)*


              
