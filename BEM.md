#Введение
БЛОК – независимый компонент, может быть переиспользован (отражает смысл). Использовать class. Не CamelCase, разделять слова «-». **Он:**
* не влияет на свое окружение (НЕ задаёт отступы, границы, позиционирование)
* не использовать в CSS селекторы по тэгам или id.
* можно вкладывать друг в друга.

*Использовать:* когда повторяется и не зависит от реализации других компонентов.
ЭЛЕМЕНТ – не может использоваться отдельно от блока. Передаёт смысл. Использовать «__» после названия блока. **Он:**
1. допускает любую вложенность.
2. всегда – часть БЛОКА, а не другого элемента. 
3. необязателен.

*Использовать:* когда не может использоваться самостоятельно.

МОДИФИКАТОР – определяет вид, состояние или поведение (размер, тема, отключен, направление). Отделяется «_» от блока/элемента. Виды:
* булевый – когда важно только наличие/отсутствие, значение не существенно. Полный вид элемента с модификатором: `search-form__button search-form__button_disabled`.
* ключ-значение – когда важно значение. Полный вид элемента с модификатором: `search-form__button search-form__button_size_m`. Невозможно указывать два одинаковых модификатора с разными значениями!

**Он:** не может использоваться в отрыве от модифицируемого блока или элемента. Изменяет вид, а не заменяет сущность. `class="search-form_theme_islands"` – неверно! нужно `class="search-form search-form_theme_islands"`

МИКС – одновременно и блок, и элемент. Позволяет совмещать поведение и стили нескольких сущностей. Например, `class="search-form header__search-form"` в `class="header"`. Позволяет задать внешнее позиционирование в `header__search-form`, но при этом `search-form` оставить независимым.

##Файловая структура.
* один блок – одна директория.
* имя блока = имя директории.
* реализация блока разделяется на отдельные файлы-технологии (.js, .css)
* директория блока – корневая для поддиректорий его элементов и модификаторов.
* директории элементов начинаются с «__», модификаторы – с «_»
* Проект состоит из уровней переопределения

Схемы организации:
* nested (классическая, все пред. пункты)
* flat (без директорий для блоков, опциональные элементы/модификаторы – в отдельных файлах или в основном файле блока)
* flex (смешанная)

##БЭМ-дерево
Абстракция над DOM. Представление структуры в терминах БЭМ. BEMJSON – объект с обязательным полем «block» для блоков и «elem». Значение «block» - название класса, «elem» - то, что ставится после «__». Если блок содержит вложенные блоки/элементы, то они попадают в поле «content» в массив субблоков/элементов.
###Реализация блока. 
Реализация – это набор технологий, которые определяют особенности сущности:
* поведение
* внешний вид
* тесты
* шаблоны
* документацию
* описание зависимостей
* доп. данные.

Блоки могут быть реализованы в одной или нескольких технологиях:

* поведение – JS, CoffeeScript
* внешний вид – CSS, Stylus, Sass
* шаблоны – Pug, Handlebars, XSL, BEMHTML, BH
* документация – Markdown, Wiki, XML

«Блог реализован в технологии» = он есть в js, css и т.д.

ПЕРЕОПРЕДЕЛЕНИЕ блока – изменение реализации, путём добавления новых особенностей на другом уровне. 
Конечная реализация может быть разделена по разным уровням переопределения. Каждый последующий – добавляет или перекрывает предыдущий. Конечный результат собирается из всех пред. уровней последовательно в заданном порядке.
###Наименование.
Имя – УНИКАЛЬНО! Сущность именуется ОДИНАКОВО!
Правила:
* латиница в нижнем регистре
* для разделения слов – дефис
* имя блока задает ПРОСТРАНСТВО имен для его элементов и модификаторов
* имя элемента – через «__»
* имя модификатора – через «_»
* значение модификатора – через «_»
* значение булевых не указывается

Существуют также альтернативные стили - Two Dashes (булевые модификаторы и значения модификаторов отделяются от блоков/элементов «--», ), CamelCase, React (блоки и элементы – с заглавной буквы, использование CamelCase вместо «-», имя элемента отделяется от имени блока через «-»).
### CSS.
НЕ используются селекторы тегов и идентификаторов. 

НЕ рекомендуется совмещать теги и классы.

МИНИМУМ вложенных селекторов.

Правила одного блока НЕ ДОЛЖНЫ влиять на внутренний мир другого блока.

НЕ рекомендуется использование вложенных селекторов.

Внешняя геометрия и позиционирование задаются через родительский блок (для переиспользования дочерних элементов).

Чтобы не использовать групповые селекторы, делаются миксы – прибавляется булевое свойство, которое описывается в CSS (`class="article text"`). 

DRY! БЭМ-сущность имеет единственное, однозначное представление!

Переопределение! (создание двух кнопок, которые отличаются только цветом – описание css блока с общими параметрами -> создание модификаторов для каждого отдельного случая).

КОМПОЗИЦИЯ ВМЕСТО НАСЛЕДОВАНИЯ!

###HTML.
Для расположения блоков относительно другого или внутри него используются МИКСЫ (ввод доп. ЭЛЕМЕНТОВ со стилями (`<header class="header page__header">...</header>`)). Если невозможно – ОБЕРТКИ (ЭЛЕМЕНТЫ, содержащие стили с позиционированием).

Руками писать – неудобно (много ошибок). Принята *автоматическая генерация* HTML. Для этого используются ШАБЛОНЫ (реализация блока, результат работы которой - HTML). Код шаблонов – по принципам организации файловой структуры (см. выше). Можно писать отдельно для всего блока, можно для каждого элемента или модификатора.

Для переопределения блока, взятого из библиотеки – создается новая папка, в которую делаются новые шаблоны – нижнее правило переопределяет верхнее.

С помощью шаблонов можно добавлять и изменять блоки на ходу (`func content()`).

###JS.
Одна из технологий реализации блока, поэтому применяются основные принципы:
* единая предметная область
* разделение кода на части (использование инкапсуляции, декларативности и наследования)
* уровни переопределения и использование сборки
Полная независимость блоков невозможна, так как:
* они могу быть подписаны на события других блоков
* вызывать методы других объектов и стат. методов класса другого блока

Выстраивать блоки необходимо в ИЕРАРХИЧЕСКОМ порядке (в соответствии с DOM). ВЛОЖЕННЫЙ блок не должен ничего знать о РОДИТЕЛЬСКОМ.

Работа с модификаторами происходит с помощью *методов-хелперов*. Изменение значений модификаторов – с помощью методов, а не меняя напрямую класс-CSS.

Реакция на установку/снятие модификатора – применяется/отключается функциональность этого модификатора.

###Уровни переопределения.
Уровень переопределения – это ДИРЕКТОРИЯ с файлами реализации блоков/элементов/модификаторов (папка common для изменения, library для добавления). Нужны, чтобы добавить/изменить файлы проекта. В одном проекте могут быть разные варианты сборки в зависимости от разных условий (например, платформа). В таком случае базовая папка будет в любом случае входить в сборку, другие – опционально. Разделять можно:
* на платформы
* для обновления библиотек блоков
* для разработки проектов с общими блоками
* для создания разных тем
* для экспериментов в рабочей среде

УДОБНО, потому что обеспечивает сохранность изменений, быстрое переключение, легко удалять ненужные варианты.

###Изменение блоков.
С помощью **МОДИФИКАТОРА**: установка/снятие. Для:
* внешнего вида
* поведения (анимация – направление открытия блока)
* состояния (отключение видимости элемента)
* структуры (добавление элемента-«хвостика» для popup)

С помощью **МИКСА** – при помощи размещении доп. сущностей на одном элементе.
* позиционирование одного в составе другого: через РОДИТЕЛЬСКИЙ блок
* единая стилизация разных сущностей

С помощью **УРОВНЯ ПЕРЕОПРЕДЕЛЕНИЯ.** 
Изменение КОНТЕКСТОМ (размещение одного блока в составе другого, лучше НЕ использовать).

##Сборка.
Так как код разделён на разные файлы, их нужно объединять в один (один js, один css и т.п.). Файлы в результате сборки = бандлы.
Нужна для: 
* объединения исходных файлов
* подключения только необходимых блоков
* учёта порядка подключения
* обработки кода исходных файлов

Этапы сборки:
1) определение сущностей
2) определение зависимостей между сущностями
3) определение порядка их подключения.

Чтобы включить в сборку только необходимые сущности, нужно составить их список – ДЕКЛАРАЦИЮ. Инструмент сборки добавляет только их. Важно, чтобы попадала ИСХОДНАЯ реализация каждого блока (уровни переопределения ее дополняют или перекрывают). ИНСТРУМЕНТЫ – любые (Gulp, ENB).

###Декларация.
Список всех сущностей в формате BEMDECL (массив объектов exports.blocks, единственный ключ в котором – name, значение – название сущности в кавычках). Составляется вручную или автоматически – по описанию страницы (БЭМ-дерево) или с помощью интроспекции файловой структуры. Их можно *складывать, вычитать* или *делать пересечение.*

#i-bem.js

##Привязка JS-блоков.
Задача js-блока – установка реакции на событие внутри HTML. HTML – первичен, точка привязки блока – DOM-узел (HTML-элемент), в атрибуте class – имя блока, а в data-bem – параметры блока. При загрузке страницы выполняется ИНИЦИАЛИЗАЦИЯ блоков (+привязка JS-блоков, которые потом обрабатывают события на элементе и хранят его состояния).

**Для привязки блока к HTML-элементу, надо:**
* декларировать блок в i-bem: методы modules.define и bemDom.declBlock получают первым аргументом строку с именем этого блока:

```
modules.define('my-block', ['i-bem-dom'], function (provide, bemDom) {
    provide(bemDom.declBlock(this.name,
        { /* методы экземпляра */},
        {  /* статические методы */}
    ));
});
```
* Добавить  HTML-элементу class с именем блока.
* Добавить в этот класс «i-bem» - это укажет фреймворку, что элемент связан с блоком JS.
* Передать параметры элементу в атрибут «data-bem» в формате JSON: 
`<div class="my-block i-bem" data-bem='{ "my-block": { "name": "ya" } }'>...</div>`

Одному блоку – НЕ ОБЯЗАТЕЛЬНО 1 элемент. Варианты:
* 1 блок – 1 элемент 
* 1 блок на нескольких элементах (указание общего id в data-bem – для согласования нескольких компонентов блока – «вкладка» (первый элемент) по клику меняет «содержимое» (второй элемент))
* одному элементу соответствует несколько блоков (МИКСЫ – zB user+avatar)
* у блока нет элемента DOM (тогда необходимо явно инициализировать и удалять)

##Декларация блока.
В разных интерфейсах реализация блока/элемента может иметь несколько экземпляров. Экземпляры имеют помимо общей функциональности свою собственную. Терминами ООП – *блок/элемент = класс, экземпляр = экземпляр класса.* Вся функциональность решается через методы. МЕТОДЫ бывают:
* статические (методы класса)
* методы экземпляра

Код блока и элемента = ДЕКЛАРАЦИЯ.

####Декларация с DOM-представлением: 

**Без родителя нового БЛОКА: *метод declBlock.*** АРГУМЕНТЫ: 
* имя (строка) или класс блока (функция)
* методы экземпляра (объект)
* методы класса (статические - объект)

Пример – см. прошлый.

**Без родителя нового ЭЛЕМЕНТА: *метод declElem.*** АРГУМЕНТЫ:
* имя (строка) или класс (функция) блока
* имя (строка) или класс (функция) элемента
* методы экземпляра (объект)
* методы класса (статические - объект)

Пример – такой же, как прошлый, только *declElem* вместо *declBlock.*

####Декларация без DOM:

Так же.

Если НЕ планируется использовать именно бэм-блоки (модификаторы и тд), то можно оформлять в виде модуля:
```
modules.define('router', function(provide) {
    provide({
        route : function() { /* ... */ }
    });
});
```
Если есть общая функциональность (разные блоки делают одинаковые запросы и тд), то можно функции оформлять в виде модулей и добавлять их к блокам. НАСЛЕДОВАНИЕ помогает расширять новой логикой. **Оно бывает:**
* простым – указывается базовый блок, передается ссылка на него во втором параметре декларации:
```
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, {}));
    });
modules.define('b-block', ['i-bem-dom', 'a-block'], function(provide, bemDom, ABlock) {
    provide(bemDom.declBlock(this.name, ABlock, {}));
});
```
**Доопределяется** на уровне переопределения:
```
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, {})); // Объявляем базовый блок
});
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom, ABlock) {
    provide(bemDom.declBlock(ABlock, {})); // Доопределяем базовый блок
});
```
Для декларации МОДИФИКАТОРА – *declMod*. АРГУМЕНТЫ:
* хеш с ключами modName (имя модификатора: строка) и modVal (значение: строка, булевое, массив)
* хеш методов (при одноименных – используется из хэша)
```
modules.define('a-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.decl(this.name, {})); // Объявляем базовый блок
});
modules.define('a-block', function(provide, ABlock) {
    provide(ABlock.declMod({ modName : 'm1', modVal : 'v1' }, {})); // Доопределяем базовый блок с модификтором _m1_v1
});
```
СТАТИЧЕСКИЕ методы НЕ будут изменены, так как относятся к классу.

Для декларации МИКСИНА  - *declMixin.* АРГУМЕНТЫ:
* методы экземпляра (объект)
* статические методы (объект)

Для ПРИМЕШИВАНИЯ МИКСИНА:
* указать примешиваемые миксиныв зависимостях
* передать ссылку на миксины во втором параметре блока (если декларируется наследование и миксин одновременно, то родительский класс – всегда ПЕРВЫЙ):
```
modules.define('b-block', ['i-bem-dom', 'a-block', 'a-mixin'], function(provide, bemDom, ABlock, aMixin) {
    provide(bemDom.declBlock(this.name, [ABlock, aMixin], {}));
});
```

УСТАНОВКА ТРИГГЕРА производится в декларации. Для них специальные свойства: *beforeSetMod* и *onSetMod.* АРГУМЕНТЫ:
* modName – имя модификатора
* modVal – выставляемое значение модификатора
* prevModVal – предыдущее значение модификатора – для *beforeSetMod*  - текущее, которое изменится на *modVal*, если триггер вернёт true
```
bemDom.declBlock(this.name, {
    onSetMod: {
        'mod1': function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
        'mod2': {
            'val1': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
            'val2': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
            '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
        },
        'mod3': {
            'true': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
            '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление простого модификатора mod3
        },
        'mod4': {
            '!val1' : function() { /* ... */ } // декларация для изменения mod4 в любое значение, кроме val1
            '~val2' : function() { /* ... */ } // декларация для изменения значения mod4 из val2 в любое другое значение
        },
        '*': function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
    }
})
```
В HTML указываются параметры в data-bem, объект, в котором ключ – имя блока, значение – объект. Если объектов много, то ключей несколько (каждый по имени блока). 

ПАРАМЕТРЫ ПО УМОЛЧАНИЮ передаются в методе *_getDefaultParams()*. Результат объединен с параметрами из атрибута (у которых больший приоритет):
```
modules.define('my-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, {
        _getDefaultParams : function() {
            return {
                param1 : 'val1'
                param2 : 'val2'
            }
        }	
    }));
});
```
ДОСТУП к параметрам из экземпляра – через *this.params.*

##Поиск других блоков. 
Каждый элемент/блок с DOM-представлением имеет поле this.domElem, которое является объектом, содержащим ссылки на все узлы, с которыми связан блок/элемент.

Поиск может вестись по трем осям:

####Внутри блока – на узлах, ВЛОЖЕННЫХ в текущий. Методы:
* findChildBlock(block)
* findChildBlocks(block)
* findChildElem(elem)
* findChildElems(elem)
####Снаружи блока, на узлах, которые являются РОДИТЕЛЬСКИМИ. Методы:
* findParentBlock(block)
* findParentBlocks(block)
* findParentElem(elem)
* findParentElems(elem)
####На СЕБЕ (в случае миксов). Методы:
•	findMixedBlock(block)
•	findMixedBlocks(block)
•	findMixedElem(elem)
•	findMixedElems(elem)

Для оптимизации – КЭШИРУЮЩИЕ методы *\*._elem(elem), \*._elems(elem)* – принимают элемент (строка, функция, объект вида `{elem : MyElem, modName : 'my-mod', modVal : 'my-val' }`) – одновременно ищет по ДВУМ ОСЯМ (внутри и на себе). НЕ сохраняется в переменную. Для БЛОКОВ - *\*._block().* ВЛОЖЕНННОСТЬ проверяется функцией *containsEntity(entity).*

##Динамическое обновление блоков.
* УДАЛЕНИЕ - *destruct(ctx, [excludeSelf]).* Параметры: *ctx* – корневой DOM-элемент. Не даляется со всеми вложенными узлами, если *\[excludeSelf\]* true. По умолчанию - false. 
* ДОБАВЛЕНИЕ:
1) *append(ctx, content)* – в конец
2) *prepend(ctx, content)* – в начало
3) *before(ctx, content)* – перед указанным
4) *after(ctx, content)* – после указанного
* ЗАМЕЩЕНИЕ:
1) *update(ctx, content)* – внутри указанного
2) *replace(ctx, content)* – заменить указанным

ДЛЯ УПРОЩЕНИЯ можно использовать ШАБЛОНИЗАТОР BEMHTML (сущности описываются в формате BEMJSON, `BEMHTML.apply` генерирует элементы по декларации)

##Состояния блоков и элементов.
Вся логика: описание состояний, которые запускаются, как только срабатывает триггер. Поэтому **описание состояния – действия, выполняемые при переходе в это состояние.**

СОСТОЯНИЕ описывается *модификаторами.* Он описывает, в каком состоянии находится блок. Список допустимых значений = набор состояний. zB для описания размеров – модификатор size со значениями s, m, l. Модификатор с неуказанным значением = булев, по умолчанию true. УСТАНАВЛИВАЮТСЯ при **инициализации** (если модификаторы используются в атрибуте class HTML-элемента). При УСТАНОВКЕ (если модификатор НЕ был указан в class HTML-элемента), ИЗМЕНЕНИИ, УДАЛЕНИИ – выполняется триггер. 

МЕТОДЫ для управления модификаторами:
* hasMod(modName, \[modVal\])
* getMod(modName) – возвращает значение модификатора
* setMod(modName, \[modVal=true\]) – устанавливает модификатор
* toggleMod(modName, modVal1, \[modVal2\], \[condition\]) – переключает модификатор. Если передан аргумент modVal2, то переключится с modVal1 на modVal2, если нет, то будет поочередно устанавливаться и удаляться. Если condition = true, то порядок переключения инвертирован
* delMod(modName)

ВЫПОЛНЕНИЕ триггеров делится на 2 фазы:
1) до установки модификатора – если хотя бы один триггер возвращает false, то модификатор не ставится
2) после установки. Отменить нельзя.

Типы изменения модификаторов для триггеров:
* любой модификатор в любое значение
* конкретный модификатор в любое значение
* конкретный модификатор в конкретное значение
* установка модификатора в значение ‘’ (пустая строка) = удаление его или false для булева
* установка конкретного модификатора в любое, кроме конкретного значения
* установка конкретного модификатора из конкретного значения в любое другое

При ОПРЕДЕЛЕНИИ триггера указывается:
1) фаза выполнения (до или после установки модификатора)
2) тип действия (имя или значение модификатора)

ФАЗА ВЫПОЛНЕНИЯ до установки модификатора, чтобы проверить, установлены ли какие-то другие модификаторы (например, нет смысла ставить focused, если стоит disabled:
```
bemDom.declBlock('searchbox', {
    beforeSetMod : {
        'focused' : {
            'true' : function() {
                return !this.hasMod('disabled');
            }
        }
    },
    onSetMod : {
        'focused' : {
            'true' : function() { /* ... */ }
        }
    }
});
```
)

##Коллекции блоков и элементов.
СОЗДАНИЕ экземпляра класса КОЛЛЕКЦИИ – с помощью класса *BemCollection,* если модуль i-bem__collection, или *BemDomCollection,* если модуль i-bem-dom__collection. В качестве АРГУМЕНТОВ принимает один аргумент-массив или несколько аргументов:
```
modules.define(
'my-form',
['i-bem-dom', 'i-bem-dom__collection', 'button', 'input'],
function(provide, bemDom, BemDomCollection, Button, Input) {
    provide(bemDom.declBlock(this.name, {
        onSetMod : {
            'js' : {
                'inited' : function() {
                    var button = this.findChildBlock(Button);
                    var input = this.findChildBlock(Input);
                    this._controls = new BemDomCollection(button, input);
                }
            }
        }
    }));
});
```
МЕТОДЫ коллекции:
* *setMod*(modName, \[modVal=true\]), *delMod*(modName), *toggleMod*(modName, modVal1, \[modVal2\], \[condition\]) – так же
* *everyHasMod*(modName, \[modVal\]), *someHasMod*(modName, \[modVal\]) = *hasMod*(modName, modVal) для каждой сущности коллекции
* *get*(i) – возвращает элемент коллекции по индексу i
* *size*() – размер коллекции
* *forEach*(fn, ctx), *map*(fn, ctx), *reduce*(fn, ctx), *reduceRight*(fn, ctx), *filter*(fn, ctx), *some*(fn, ctx), *every*(fn, ctx), *has*(entity), *find*(fn, ctx), *concat*(...args) – методы массива
* *toArray*() – преобразовывает коллекцию в массив

##События.
События бывают 2х видов: DOM и БЭМ. Первые – только для взаимодействия со своим узлом и своими блоками, для взаимодействия с другими блоками – БЭМ-события.

###DOM-СОБЫТИЯ

ИЗ ЭКЗЕМПЛЯРА

Для ПОДПИСКИ на событие - *_domEvents()*, который создаёт специальный объект менеджера событий. Принимает 1 параметр (опционально), который ЗАДАЁТ КОНТЕКСТ. Виды:
* *elemInstance* {Elem|BemDomCollection} – экземпляр или коллекция элементов
* *elemClass* {String|Function|Object} – класс, имя или описание объекта (в виде хэша `{elem : MyElem, modName : 'my-mod', modVal : 'my-val'}`) 
* *document* {Document|jQuery}
* *window* {Window|jQuery}

zB:
```
bemDom.declBlock('my-form', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this._domEvents('button').on('click', this._onSubmit);
            }
        }
    },
    _onSubmit : function() { /* ... */ }
});
```
ИЗ КЛАССА – статический метод *_domEvents().* Принимает:
* *elemClass* {String|Function|Object} – класс, имя или описание вида `{elem : MyElem, modName : 'my-mod', modVal : 'my-val' }`
* *document* {Document|jQuery}
* *window* {Window|jQuery}

zB:
```
bemDom.declBlock('my-form', {
    _onSubmit : function() { /* ... */ }
}, {
    lazyInit : true,
    onInit : function() {
        this._domEvents('button').on('click', this.prototype._onSubmit);
    }
}); //при нажатии на любую кнопку класса, будет выполняться _onSubmit
``` 
УДАЛЕНИЕ подписки – автоматически при удалении экземпляра, или через *_domEvents().un*

Первым аргументом функция-обработчик получает объект события, поэтому можно использовать *stopPropagation* и *preventDefault,* чтобы остановить всплытие и реакцию браузера.

##БЭМ-СОБЫТИЯ
Генерируются НЕ на DOM, а на экземплярах блоков.
Для генерации – метод *_emit(event, \[data\]).* event – имя или объект события, \[data\] – доп данные для события.

Взаимодействие пользователя с блоком -> DOM-событие -> обработка событий блоком -> создание БЭМ-события.
####ИЗ ЭКЗЕМПЛЯРА
ПОДПИСКА – метод *_events(),* который создает объект менеджера событий. Принимает параметр, задающий КОНТЕКСТ. Виды:
* *entityInstance* {Elem|BemDomCollection} – экземпляр или коллекция сущностей
* *entityClass* {String|Function|Object} – класс, имя или описание (хэш все того же вида)

zB:
```
modules.define('my-form', ['i-bem-dom', 'button'], function(provide, bemDom, Button) {
    provide(bemDom.declBlock(this.name, 
        {
        _onSubmit: function() { /* ... */ }
        }, 
        {
            lazyInit : true,
            onInit : function() {
                this._events(Button).on('click', this.prototype._onSubmit)
            }
        }
    ));
});
```
Существуют так же специальные события на ИЗМЕНЕНИЕ МОДИФИКАТОРОВ. Используется хэш с полями modName – имя, modVal – значение. Значение «*» - применяется к изменению на все изменения, «””» - на удаление модификатора.

####ОБЪЕКТ МЕНЕДЖЕРА СОБЫТИЙ
* метод on(event, \[data\], fn) – для подписки на событие event обработчика fn с возможностью передать ему данные \[data\].
* метод once(event, \[data\], fn) – единоразовая подписка
* метод un(\[event\], \[fn\]) – для отписки. Если не указан обработчик fn, то удаляются все обработчики события.

zB:
```
modules.define('my-form', ['i-bem-dom', 'button'], function(provide, bemDom, Button) {
    bemDom.declBlock('form', {
        onSetMod: {
            'js': {
                'inited': function() {
                    this._events(this.findChildBlock(Button))
                        .on({ modName : 'disabled', modVal : '*' }, this._onButtonDisabledChange);
                }
            }
        },
        _onButtonDisabledChange() {}
    });
});
```

##Инициализация
Создание в памяти браузера js-объекта, который соответствует экземпляру блока или элемента. Выполняется функцией *init(\[ctx\])* на заданном фрагменте DOM-дерева ctx. Существует в 3 состояниях:
1) не создан объект = не инициализирован
2) создан объект = инициализирован
3) уничтожены все ссылки, может быть удалён gc

Описываются с помощью модификатора js – `<div class="my-block i-bem my-block_js_inited" data-bem='{ "my-block" : {} }'>...</div>` - модификатор в значении inited.

Если фрагмент DOM-дерева удалён (метод *destruct()*), то с ним удаляются все элементы. Перед удалением убирается модификатор JS.

На установку модификатора js можно назначить ТРИГГЕР (его можно считать конструктором):
```
bemDom.declBlock('my-block', {
    onSetMod : {
        'js' : {
            'inited' : function() { /* ... */ } // конструктор экземпляра
        }
    }
});
```
Деструктор – триггер на УДАЛЕНИЕ (вместо 'inited' - '').

Инициализируются не сразу все блоки (динамически, по событию или запросу) – это ВОЛНЫ инициализации. Создаются, если:
* автоматически по событию *domReady*
* ленивая инициализация
* явный вызов инициализации на указанном фрагменте

АВТОМАТИЧЕСКИ можно включить, указав это в файле зависимостей *.deps.js*:
```
({
    shouldDeps : [
        {
            block : 'i-bem',
            elem : 'dom',
            mods : { init : 'auto' }
        }
    ]
})
```
ЛЕНИВАЯ – если много элементов, то нежелательно использовать автоматическую инициализацию, только в тот момент, когда она требуется пользователю (например, по клику). Для декларации такой загрузки – статическое свойство *lazyInit* (булево значение):
```
modules.define('my-block', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, 
        {
            onSetMod : {
                'js' : {
                    'inited' : function() {
                        // этот код будет выполняться при первом обращении к экземпляру блока
                    }
                }
            }
        }, 
        {
            lazyInit : true
        }
    ));
});
```
Можно отменить для конкретного экземпляра, установив в HTML `data-bem='{ "my-block" : { "lazyInit" : false } }'`.

Для класса  - специальный дополнительный метод onInit, внутри которого можно подписаться на события:
```
modules.define('button', ['i-bem-dom'], function(provide, bemDom) {
    provide(bemDom.declBlock(this.name, 
        {
            onSetMod : {
                'js' : 
                    {
                    'inited' : function() { // выполняется при первом DOM-событии "click" }
                    }
                },
                _onClick: function(e) { // выполняется при каждом DOM-событии "click" }
            }, 
            {
                lazyInit : true,
                onInit : function() {
                    this._domEvents().on( 'click', this.prototype._onClick);  // в момент клика будет создан экземпляр блока и вызван его метод _onClick
            }
        }
    ));
});
```
**NB!** Методы – СТАТИЧЕСКИЕ, поэтому будут применены КО ВСЕМ ЭКЗЕМПЛЯРАМ класса!

Инициализация может быть вызвана ЯВНО (при динамическом обновлении). Для этого методы:
* *init(), destruct()* – инициализация и уничтожение экземпляров
* *update(), replace(), append(), prepend(), before(), after()* – обновление фрагмента дерева с одновременной инициализацией.
####БЕЗ DOM
Для ИНИЦИАЛИЗАЦИИ – статический метод *create().* АРГУМЕНТЫ:
* *mods* (объект) – модификаторы
* *params* (объект) – параметры блока/элемента

Автоматически НЕ удаляются (так как это обычные объекты, их подчищает gc после уничтожения всех ссылок на него).

##Взаимодействие блоков и элементов. 
Следует разрабатывать так, чтобы состояния сущностей НЕ ЗАВИСИЛИ от других сущностей. Но на практике – так себе получается.

Взаимодействие реализовано:
* подписками на БЭМ-события
* непосредственный вызов других экземпляров и статических методов класса
* проверка состояния одного экземпляра из другого
* НЕ ИСПОЛЬЗОВАТЬ ДЛЯ ЭТОГО DOM!

Для реализации взаимодействия:
* поиск экземпляров в DOM
* доступ к экземплярам без DOM
* доступ к классам и объектам

##Контекст
В методах ЭКЗЕМПЛЯРА **this** указывает на экземпляр, в СТАТИЧЕСКИХ – на класс. Внутренние методы, которые не используются извне, принято начинать с «_».

**Свойства и методы:**
* *params* (параметры, переданные в HTML или экземпляру при инициализации (если нет DOM-представления))
* *domElem* (только у сущностей с DOM-представлением) – объект jQuery с ссылками на DOM-элементы
* *__self* – для доступа к статическим методам из экземпляра:
```
bemDom.declBlock('my-block', 
    {
        _onEvent : function() {
            this.__self.staticMethod(); // вызов статического метода
            this.doMore();
        }
    }, 
    {
        staticMethod : function() { /* ... */ } // определение статического метода
    }
);
```
* *__base*  - для вызова реализации одноименного метода из класса-родителя («super call»)
* *_nextTick(fn)* – асинхронно вызывает fn в следующем витке событий. Вызывается в контексте данного экземпляра, если он ещё существует

#BEMJSON
##Стандартные поля:
* *block* – имя блока (строка)
* *elem* – имя элемента  (строка)
* *mods* – хеш модификаторов БЛОКА – объект. Ключи – любые, значения – строка или булево. Будет ПРОИГНОРИРОВАН, если указаны elem и elemMods
* *elemMods* – хеш модификаторов ЭЛЕМЕНТА –II– ИГНОРИРУЕТСЯ, если не указан elem
* *content* – дочерние узлы. Объект с полем html – специальная сущность, значение – строка, которая будет выведена без изменений. Остальное ИГНОРИРУЕТСЯ
* *mix* – примиксованные сущности (объект, строка)
* *bem* – нужно ли дополнять классы и параметры для самой БЭМ-сущности (булево – если false, то в результате HTML не изменится)
* *js* – параметры (объект/булево – если не false, то миксует i-bem и добавляет содержимое в data-bem: 
```
// BEMJSON
{
   block: 'link',
   js: true
})
//HTML
<div class="link i-bem" data-bem='{"link":{}}'></div>
```
При этом кавычки и спец. символы будут экранированы)
* *attrs* - хеш HTML-атрибутов (объект. спец. символы экранируются:
```
// BEMJSON
{
    attrs: {
        id: 'anchor',
        name: 'Мультфильм "Tom & Jerry"'
    }
}
//HTML
<div id="anchor" name="Мультфильм &quot;Tom &amp; Jerry&quot;"></div>
```
)
* *cls* - HTML-класс (строка – класс или классы, которые не принадлежат БЭМ)
* *tag* - HTML-тэг (булево/строка. Если false или '' – указание пропустить генерацию этого тэга. По умолчанию - div)
* *пользовательские поля*

#bem-xjst
Шаблонизатор на двух движках: 
* BEMHTML для преобразования BEMJSON в HTML
* BEMTREE для навешивания на BEMJSON БЭМ-дерева и преобразования этого в HTML

##Написание шаблона.
Шаблон состоит из:
* **предиката** (у каждого шаблона прописываются входные условия, подпредикаты, они составляют предикат). Бывают:
1) *block* (запрашивает подпредикат имени блока)
2) *elem* (то же самое, но элемента)
3) *mod* (запрашивает modName, modVal)
4) *elemMod* (elemModName, elemModVal)
5) *match* (`(node, ctx) => { return … }` проверка произвольного условия. Результат приведён к булеву значению)

Чейнятся. Можно вкладывать друг в друга во избежание дублирования кода.
* **тела** (инструкция по генерации результата работы шаблона). Шаблонизация каждого узла входных данных состоит из режимов (тэг, HTML-класс, атрибуты, содержание тэга). РЕЖИМ = вызов функции. Нельзя в сам режим передавать аргументы. Тело шаблона – отдельный вызов функции, который ожидает аргумент (`block('b').content()('test')`); 
или:
```
block('link')({
   tag: 'a',
   attrs: (node, ctx) => ({ href: ctx.url })
}); 
```
для сокращённого вида).
##СТАНДАРТНЫЕ режимы:
* *def* (def: value) – отвечает в целом за генерацию результата. Не стоит пользовать.
* *tag* (tag: name, по умолчанию div) – тэг. Если отсутствует – то пропускается
* *attrs* (attrs: value) – хэш с атрибутами. Более коротко - `addAttrs: { id: 'test', name: 'test' }`
* *content* – дочерние узлы. Чтобы добавить в содержимое - *appendContent* и *prependContent.*
zB:
```
block('quote')(
    {
        prependContent: '«',
        appendContent: '»'
    },
    {
        appendContent: () => ({ block: 'link' })
    }
);
{ block: 'quote', content: 'Пришел, увидел, отшаблонизировал' }
```
Результат:
```
<div class="quote">«Пришел, увидел, отшаблонизировал»<div class="link"></div></div>
```

По сути – синтаксический сахар над *applyNext().*
* *mix* – сущности, которые примиксовываются (либо `{ mix: { block: 'mixed' } }`, либо массив объектов, либо функция, либо `addMix: 'my-new-mix'`)
* *mods* – модификаторы блока. Для добавления – *addMods* (ключом – хэш модификаторов)
* *elemMods* – модификаторы элемента (всё то же самое)
* *js* – если не false, то миксует i-bem и добавляет содержимое в js параметры
* *bem* – указывает, добавлять ли классы и параметры для БЭМ и миксов
* *cls* – добавить любой класс, который не относится к БЭМ

##ХЕЛПЕРЫ
* *replace* – для подмены текущего узла
* *wrap* – для обертки узла:
```
{
    block: 'quote',
    content: 'Docendo discimus'
};
block('quote')({
    wrap: (node, ctx) => ({
        block: 'wrap',
        content: ctx
    })
});
```
Результат:
```
<div class="wrap">
    <div class="quote">Docendo discimus</div>
</div>
```
* *extend* – доопределить контекст:
```
{ block: 'action' };
block('action')({
    extend: { 'ctx.type': 'Sale', sale: '50%' }
});
block('action')({
    content: (node, ctx) => ctx.type + ' ' + node.sale
});
```
Результат:
```
<div class="action">Sale 50%</div>
```
Если указать «*», то распространяется на все дочерние блоки/элементы.
* *пользовательские режимы:* сам решаешь, что и как:
```
{ block: 'control', name: 'username', value: 'miripiruni' }

block('control')(
    {
        id: 'username-control', // Пользовательский режим с именем id
        content: (node, ctx) => {
            return [
                {
                    elem: 'label',
                    attrs: { for: apply('id') } // Вызов пользовательского режима
                },
                {
                    elem: 'input',
                    attrs: {
                        name: ctx.name,
                        value: ctx.value,
                        id: apply('id')  // Вызов пользовательского режима
                    }
                }
            ];
        }
    },
    elem('input')({ tag: 'input' }),
    elem('label')({ tag: 'label' })
);
```
Результат:
```
<div class="control">
    <label class="control__label" for="username-control"></label>
    <input class="control__input" name="username"
        value="miripiruni" id="username-control" />
</div>
```